diff --git a/js/xpconnect/src/XPCWrappedNative.cpp b/js/xpconnect/src/XPCWrappedNative.cpp
--- a/js/xpconnect/src/XPCWrappedNative.cpp
+++ b/js/xpconnect/src/XPCWrappedNative.cpp
@@ -1391,53 +1391,16 @@ XPCWrappedNative::SystemIsBeingShutDown(
     if (mFirstChunk.mNextChunk) {
         delete mFirstChunk.mNextChunk;
         mFirstChunk.mNextChunk = nullptr;
     }
 }
 
 /***************************************************************************/
 
-// If we have to transplant an object across compartments, we need to be
-// careful if the underlying object implements nsWrapperCache and is preserving
-// the wrapper.
-//
-// The class brackets a pair of Unpreserve/Preserve calls in the given scope.
-//
-// This class _must_ live on the stack, in part so that mPreservedWrapper is
-// visible to the stack scanner. The caller wants the wrapper to be preserved,
-// so we don't want it to get accidentally GCed.
-class AutoWrapperChanger NS_STACK_CLASS {
-public:
-    AutoWrapperChanger() : mCache(nullptr)
-                         , mCOMObj(nullptr)
-                         , mPreservedWrapper(nullptr)
-    {}
-
-    void init(nsISupports* aCOMObj, nsWrapperCache* aWrapperCache) {
-        mCOMObj = aCOMObj;
-        mCache = aWrapperCache;
-        if (mCache->PreservingWrapper()) {
-            mPreservedWrapper = mCache->GetWrapper();
-            MOZ_ASSERT(mPreservedWrapper);
-            nsContentUtils::ReleaseWrapper(mCOMObj, mCache);
-        }
-    }
-
-    ~AutoWrapperChanger() {
-        if (mPreservedWrapper)
-            nsContentUtils::PreserveWrapper(mCOMObj, mCache);
-    }
-
-private:
-    nsWrapperCache* mCache;
-    nsISupports* mCOMObj;
-    JSObject* mPreservedWrapper;
-};
-
 // Dynamically ensure that two objects don't end up with the same private.
 class AutoClonePrivateGuard NS_STACK_CLASS {
 public:
     AutoClonePrivateGuard(JSObject *aOld, JSObject *aNew)
         : mOldReflector(aOld), mNewReflector(aNew)
     {
         MOZ_ASSERT(JS_GetPrivate(aOld) == JS_GetPrivate(aNew));
     }
@@ -1467,26 +1430,20 @@ XPCWrappedNative::ReparentWrapperIfFound
         XPCNativeInterface::GetISupports(ccx);
 
     if (!iface)
         return NS_ERROR_FAILURE;
 
     nsresult rv;
 
     nsRefPtr<XPCWrappedNative> wrapper;
-    AutoWrapperChanger wrapperChanger;
     JSObject *flat = nullptr;
     nsWrapperCache* cache = nullptr;
     CallQueryInterface(aCOMObj, &cache);
     if (cache) {
-
-        // There's a wrapper cache. Make sure we keep it sane no matter what
-        // happens.
-        wrapperChanger.init(aCOMObj, cache);
-
         flat = cache->GetWrapper();
         if (flat && !IS_SLIM_WRAPPER_OBJECT(flat)) {
             wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
             NS_ASSERTION(wrapper->GetScope() == aOldScope,
                          "Incorrect scope passed");
         }
     } else {
         rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, aOldScope, iface,
@@ -1661,18 +1618,22 @@ XPCWrappedNative::ReparentWrapperIfFound
                 wrapper->SetWrapper(ww);
             } else {
                 flat = xpc::TransplantObject(ccx, flat, newobj);
                 if (!flat)
                     MOZ_CRASH();
             }
 
             wrapper->mFlatJSObject = flat;
-            if (cache)
+            if (cache) {
+                bool preserving = cache->PreservingWrapper();
+                cache->SetPreservingWrapper(false);
                 cache->SetWrapper(flat);
+                cache->SetPreservingWrapper(preserving);
+            }
             if (!JS_CopyPropertiesFrom(ccx, flat, propertyHolder))
                 MOZ_CRASH();
         } else {
             SetSlimWrapperProto(flat, newProto.get());
             if (!JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject()))
                 MOZ_CRASH(); // this is bad, very bad
         }
 
